{
  "name": "throwarm",
  "version": "1.0.1",
  "description": "Thowarm allows you to parse data sets like SQL results into re-useable, hierarchal objects.",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "devDependencies": {
    "mocha": "~1.1.0",
    "should": "~0.6.3"
  },
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jrosendahl/throwarm.git"
  },
  "keywords": [
    "ORM",
    "Database"
  ],
  "author": {
    "name": "John Rosendahl"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "10936525c2a26f1c82816b6ceb3bbb77e77c04f5",
  "readme": "Throwarm\n======\nThowarm allows you to parse data sets like SQL results into re-useable, hierarchal objects.\n\n#Why does this exist?\nThrowarm seeks to gain some of the advantages of an ORM without the weight or complexity.  The idea is to allow developers to use normal SQL commands to interact with the database, but once results are returned, the developer can use throwarm to interact with the results set as a hierarchal set of objects.\n\n#Overview\n##Installing throwarm\nto install throwarm use npm → npm install throwarm\n\n##Using throwarm\nUsing throwarm is a three part process 1) creating throwarm objects, 2) creating a Datastructure, 3) applying data to the Datastructure\n\n###Creating throwarm objects\nThere are two different types of throwarm objects: Datagrams and Datasets.   Datagrams are objects that hold a single result, analogous to a table row.  Datasets are array objects that hold sets of Datagrams,they are analogous to a table. \n\n####Datagrams\nTo create a Datagram, you create an function,  make a base call to the datagram constructor and then set the default field map.  The default field map is matches the fields in the database table the datagram represents.\n\nFor Example: \n```javascript\nvar Datagram = require('throwarm').Datagram;\nfunction Parent() {\n\tObject.defineProperty(this,'base',{value:Datagram,writable:false,configurable:true,enumerable:false});\n\n\tthis.base(this);\n\tthis.fieldMap =  {\n\t\tid:'mainID',\n\t\tname: 'mainName',\n\t\tproperty1: 'mainProperty'\n\t};\n\n}\nParent.prototype = new Datagram();\nParent.prototype.constructor = Parent;\n```\n\n####Datasets\nDataset creation uses slightly different syntax.  Since datasets do not have fields they do not have a field map.  They do however have a type name that should match the name of the Dataset.\n\nFor Example:\n```javascript\nfunction Children() {\n\tvar children = new Dataset();\n\tchildren.typeName= 'Children';\n\treturn children\n}\n```\n\n####Extending Datagrams\nOnce you have created the base datagram they can be extended by adding functions to the objects prototype.\nFor example the following code defines a Datagram and extends it.\n```javascript\nfunction Child() {\n\tObject.defineProperty(this,'base',{value:Datagram, writable:false,configurable:true,enumerable:false});\n\n\tthis.base(this);\n\tthis.fieldMap =  {\n\t\tid:'childID',\n\t\tname: 'childName',\n\t\tproperty1: 'childProperty',\n\t\ttype: 'childType'\n\t};\n\n}\n\nChild.prototype = new Datagram();\nChild.prototype.constructor = Child;\n\n\n//here is a simple function \nChild.prototype.isFast = function() {\n\tvar self = this;\n\treturn self.property1 === 'Fast';\n};\n```\n####Extending Datasets\nDatasets must be extended within the definition function the following code extends the Children Dataset:\n```javascript\nfunction Children() {\n\tvar children = new Dataset();\n\tchildern.typeName= 'Children';\n\n\t//I am adding a function to the object\n\tfunction getByType(type) {\n\t\tvar self = this;\n\t\tfunction byType(child) {\n\t\t\treturn child.type === type;\n\t\t}\n\t\treturn self.copyReturn(self.filter(byType), new Children());\n\t}\n\tObject.defineProperty(children,'getByType',{value:getByType,writable:false,configurable:false,enumerable:false});\n\t\n\tfunction getById(id) {\n\t\tvar self = this;\n\t\tfunction byID(child) {\n\t\t\treturn child.id == id;\n\t\t}\n\t\tvar child = self.filter(byID);\n\t\tif(child.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn child[0];\n\t}\n\n\tObject.defineProperty(childern,'getById',{value:getById,writable:false,configurable:false,enumerable:false});\n\t\n\t//Once the definition is complete you must return the object\n\treturn children;\n}\n```\n##Creating a Datastructure\nDatastructures are a collection of Datagrams and/or Datasets in any hierarchy.  Children are added to datagrams by adding to the fieldMap property.  Children are added to Datasets by setting the items and key properties. \n\nFor example (using the previously defined Datasets and Datagrams:\n```javascript\nvar parentWithKids = new Parent();\nparentWithKids.fieldMap.kids = new Children();\nparentWithKids.fieldMap.kids.key = 'childID';\nparentWithKids.fieldMap.kids.items = function () {\n\tvar child = new Child();\n\treturn child;\n};\n```\nAs you can see the fieldMap for the Parent Datagram is extended by adding a new Children datagram to the field map as kids.  The Children datagram is extended by setting the key which is the name of the field that will be used to identify unique rows. For each unique key value a new element (defined by items) will be created.  Items is a function that returns the type of datagram to be created.\nYou can use multiple Datastructures to describe the same data.\n\nFor instance:\n```javascript\nvar kidsWithParent = new Childern();\nkidsWithParent.key = 'childID';\nkidsWithParent.items= function() {\n\tvar child = new Child();\n\tchild.fieldMap.parent = new Parent();\n\treturn child;\n};\n```\n##Applying Data\nOnce a Datastructure has been created you can add data to the objects by invoking the fill method supplying an array of structures.\n\nFor example the following data may have come from the following SQL Query: \n```SQL\nSelect * from Parents left Join Children on Parents.mainID = Children.mainID where mainID = 123\n```\nReturns the data object below:\n```javascript\ndata = [\n\t{mainID:123\n\tmainName:'Parent Name',\n\tmainProperty:'Taller than children',\n\tchildID:1,\n\tchildName:'Billie',\n    childProperty:'Fast',\n\tchildType:'Good'},\n\t{mainID:123\n\tmainName:'Parent Name',\n\tmainProperty:'Taller than children',\n\tchildID:2,\n\tchildName:'Jimmy',\n    childProperty:'Slow',\n\tchildType:'Bad'},\n]\n```\nTo populate the Datadtructure call the fill functon on the top object\n\n```javascript\nparentWithKids.fill(data);\n```\nThis will result in the following object\n```javascript\n{id:123,\nname:'Parent Name',\nproperty1:'Taller than children',\nkids:[\n\t{id:1, name:'Billie',property1:'Fast',type:'Good'},\n\t{id:2, name:'Jimmy', property1:'Slow',type:'Bad'}\n]\n```\nAdditionally, you can call the methods you have added to the Datasets and Datastructure for example\n\nkidsWithParents.kids[0].isFast() will return true.\n\nSee the test file for more examples.\n\n#Helper Functions\n##Datagram\nhas(key, type) – returns true if the the key contains the type. For example kidsWithParents.has('kids','Children') returns true\n\n##Dataset\nhas (type) – returns true if the dataset is populated by the requested type.  For example  kidsWithParents.kids.has('Child') returns true.\n\ncopyReturn(sourceArray, destinationDataset)– returns the source array as the destination dataset.\n\nQuestions, comments, concerns please let me know.",
  "bugs": {
    "url": "https://github.com/jrosendahl/throwarm/issues"
  },
  "homepage": "https://github.com/jrosendahl/throwarm",
  "_id": "throwarm@1.0.1",
  "_shasum": "f3d2483aeba9f6b6f81ed0b52216fb8b36a5e5ff",
  "_from": "throwarm@",
  "_resolved": "https://registry.npmjs.org/throwarm/-/throwarm-1.0.1.tgz"
}
